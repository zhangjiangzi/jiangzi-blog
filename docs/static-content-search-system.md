<img src="/images/meow.gif" style="max-width: 25rem; margin: 3rem auto;" />

最近在工作中，还蛮经常遇到公司官网内的帮助文档，新闻这些静态内容的搜索功能存在问题的反馈的，像功能被反馈“不好用”这样的评价。而要验证功能是不是“好用”这种主观评价，以及问题出在哪里也蛮难去量化和拆解的，特别是没有设置用户侧埋点的情况。

在开发静态内容搜索功能时，如果你也遇到类似这样的情况：

- 用户反馈黑盒，无法验证现有接入的前端搜索工具是否满足我们的搜索需求
- 无法在技术选型时前置对几个搜索方案进行横向对比

不妨继续读下去，大概 15 分钟，希望能给你带来一些启发 ~

<hr />

在开始进入主题之前，先前置说明一下“静态内容搜索能力”指的是什么东西：

大多数的搜索场景下，搜索这个行为发生在服务端，而前端只需要通过发送请求获取需要搜索到的结果。
但在一些 SSG 网站下，所有内容都为静态内容，**前端可以获取到被搜索的所有文档数据**，需要由一些前端搜索方案负责建立索引，
建立索引的过程可能是在构建时，也可能在运行时。

而我们将要讨论的这个验证体系要提出的就是如何去验证这些前端搜索方案的搜索能力。

## 那么应该如何衡量搜索能力？

以下是一些可能的衡量标准：

1. 有效性和准确性：搜索结果是否准确 <br/>
   ✅ **准确度**<br/>
   ✅ **召回率** <br/>
   ✅ **排序合理程度**
2. 效率：对一个 query，能够多快得到结果，需要多少的计算资源<br/>
   ✅ 衡量空间和**时间开支**
3. 可用性：一个系统对一个真实的用户来说有用的程度<br/>
   🙈 <strike>用户反馈</strike>

> 可用性的收集通常来自用户的反馈，虽然说用户的反馈是非常重要的衡量依据，但在我们讨论这个问题时，是在假定无法获取用户反馈数据的前提下进行的。

在这个基础上，要衡量一个搜索工具是否好用，我们需要搜集以下指标：

- 准确度(Precision)
- 召回率(Recall)
- 排序合理程度
- 计算耗时

这几个指标从各个维度对搜索工具进行评价，接下来介绍我是如何计算它们的。

## 如何计算这些指标呢？

在衡量搜索能力上，我们是希望可以通过数值去表现它的各方面能力的，这个数值应该是精确的一个数字，不同对象的同一个指标是在一个标准体系内产生才有可比性。这一部分说明的是各个指标的产生依据。

### 1. 准确度(Precision) 和 召回率(Recall)

准确率和召回率是一个成对的指标，它俩计算通常是基于同一数据的，对于准确率和召回率的计算方式已经有相关的标准，以下简单阐述一下：

| 文档是否相关\是否被检索到  | 检索到   |  没有检索到 |
| :--------  | :-----  | :----:  |
| 相关 | a| b |
| 不相关 | c|d|

其中 a,b,c,d 分别对应位置的数量。

准确率：搜索结果中，与 query 相关的文档在搜索结果的占比。也就是衡量检索的结果是否都是相关的

<center> $Precision = \frac{a}{a+c}&emsp;(0 \le  Precision \le  1)$ </center>

召回率：搜索结果中，与 query 相关的文档在所有实际与 query 相关的文档的占比。也就是衡量相关的文档是否全部都被检索到了

<center>$Recall = \frac{a}{a+b}&emsp;(0 \le  Recall \le  1)$</center>

除了准确率和召回率之外，这里其实还引入了一个调和平均数 F1。

### 2. 调和平均数 F1

理想情况下，我们希望准确率和召回率有 𝑃𝑟𝑒𝑐𝑖𝑠𝑖𝑜𝑛 = 𝑅𝑒𝑐𝑎𝑙𝑙 = 1.0，但是**实际上高的召回率通常意味着较低的准确率**！

我们引入调和平均数 F1，对准确率和召回率进行权衡：

<center>$F1 = \frac{2PR}{P+R}&emsp;(0 \le  F1 \le  1)$</center>

有了调和平均数，我们就可以在 𝑃𝑟𝑒𝑐𝑖𝑠𝑖𝑜𝑛 和 𝑅𝑒𝑐𝑎𝑙𝑙 之间取得一个平衡值，从而更清晰的帮助我们体现准确率和召回率的综合情况。当然 F1 的计算方法可以不是固定的，目前我们假定准确率和召回率的权重相同，具体要看实际场景。

对于调和平均数，你可能会想问：我们为什么不用 0.5P + 0.5R 来衡量一个算法呢？答案是，如果计算算法平均值，而算法平均值都是用的和来计算的，那么算法平均值的结果就会被一个非常大的值所左右，而几乎不用考虑其余小的值的影响！而调和平均数 F1 可以避免这种情况。

### 3. 排序合理分数

> 终于到了第三个指标，排序合理分数。这是个人认为非常重要的一个搜索能力衡量指标。不过需要注意的是，它的计算是基于一些现有算法，但是结果的计算是经过一些策略处理，是有可能不严谨的。

那么，如何衡量搜索结果的排序是合理的？如何确认搜索算法是否将相关度更高的结果展示在更前的位置呢？

对于搜索排序的能力，有一个简单的解释，衡量排序合理程度实际上就是衡量 query 和文档的相关度的**计算是否合理**。不过目前并没有找到一个前置的验证方式，但是我想介绍一个在信息检索领域的算法：

DCG（Discounted cumulative gain）折损累计增益，用来衡量和评价搜索结果的算法。

它是一个对**搜索结果**的**相关程度**进行衡量计算得分的算法。简单来说，在一组搜索结果中，用户对于各个结果具有不同的喜爱程度，用户对于排在前面的搜索结果喜爱程度越高，说明排序的合理程度越高，反之，如果用户对于排在后面的搜索结果喜爱程度更高，排序合理评分也就越低。

DCG 算法的两个思想：

1. 高关联度的结果比一般关联度的结果更影响最终的指标得分；
2. 有高关联度的结果出现在更靠前的位置的时候，指标会越高；

在描述 DCG（折损累计增益） 的计算方式之前，先说明一下累计增益（Cumulative Gain，CG）是个什么东西吧。

CG，也称为 Cumulative Gain（累计增益），表示在一个排名列表中，根据排名顺序逐个累加每个项目的相关度得分，从而衡量排序质量。

指定位置 p 上的 CG 为：

<center>$CG_{p} = \sum_{i=1}^{p}rel_{i}$</center>

$rel_{i}$ 代表 i 这个位置上的相关度。

DCG， Discounted 的 CG，就是在每一个 CG 的结果上处以一个折损值。

为什么要这么做呢？目的就是为了让排名越靠前的结果越能影响最后的结果。假设排序越往后，价值越低。

到第 i 个位置的时候，它的价值是 $\frac{1}{\log_{2}{(i+1)} }$，那么第 i 个结果产生的效益就是 $rel_{i}\frac{1}{\log_{2}{(i+1)} }$，所以：

<center>$DCG_{p} = \sum_{i=1}^{p}\frac{rel_{i}}{\log_{2}{(i+1)} } = rel_{1} + \sum_{i=2}^{p}\frac{rel_{i}}{\log_{2}{(i+1)} }$</center>

还有另外一种 DCG 的算法：

<center>$DCG_{p} = \sum_{i=1}^{p}\frac{2^{rel_{i}} - 1}{\log_{2}{(i+1)} }$</center>

NDCG 算法是对 DCG 的结果进一步进行归一化处理。实际上，只使用 DCG 并不是不需要归一化，而是我选择了使用 BM25 的计算结果进行进一步的归一化处理，当然这部分在下文会细细道来～

### 4. 计算耗时

这个理解就比较简单，计算的耗时是指从开始搜索到获取结果所消耗的时间。

<center>$T = T_{end} - T_{start}$</center>

在一般情况下，搜索数据量大概在几十篇文章，各个搜索工具表现大差不差，这个指标的权重反而显得不是特别重要。但如果搜索数据量在上百，几百篇文章，搜索速度会成为我们必须考虑的问题。特别是在浏览器执行大量的搜索计算可能会对主线程造成阻塞，当然这个问题可以通过 Web Worker 或者其他方案去解决，但长时间的 loading 也是非常影响用户体验的。

## 使用 BM25 作为衡量基准

在前面的阅读中，只是大致介绍了几个指标的定义和公式，你可能会发现，像准确率、召回率以及排序合理分数的计算是基于一个标准结果的。在接下来的一部分会说明的是，这个标准结果是如何获取的。

先不着急，我们先来回答一个重要的问题：如何判断一个 query 与一个文档是否相关以及它们之间的相关程度呢？

这个问题是一个非常重要且棘手的问题，搜索出来的结果是否准确相关对于不同的用户有不同的答案。我们需要找到一个尽可能的符合大部分用户认知上的对于 query 和文档的相关程度的算法。相关算法不是很多，结论是我选择了 BM25。

### 那么什么是 BM25 ？

Okapi BM25，一般简称 BM25 算法，在 20 世纪 70 年代到 80 年代，由英国一批信息检索领域的计算机科学家发明。这里的 BM 是“最佳匹配”（Best Match）的缩写。

在信息检索领域，BM25 算法是工程实践中举足轻重的重要的 Baseline 算法。迄今为止距 BM25 的提出已经过去三十多年，但是这个算法依然在很多信息检索的任务中表现优异，是很多工程师首选的算法之一。

简单来说，BM25 算法实质上是一个用于信息检索中，对给定查询（query）和若干“相关”文档（document）进行相关性排序打分的排序函数。一般情况下，这个相关性打分是一个类似 TF-IDF 的基于统计计数的无监督学习过程。

下面是它的思想和简写公式：

- 对 query 进行特征提取分解，生成若干特征项（词）𝑞𝑖；
- 然后对于每个搜索结果 𝐷，计算每个特征 𝑞𝑖 与 𝐷 的相关性得分；
- 最后，将 𝑞𝑖 相对于 𝐷 的相关性得分进行加权求和，从而得到 query 与 𝐷 的相关性得分。

<center style="margin-top: 1rem;">$score(q, d) = \sum_{i} W_i \cdot R(q_i, d)$</center>

其中，𝑞 表示 query；𝑞𝑖 表示 𝑞 分解之后的一个特征项（对中文而言我们可以把对 query 的分词作为基本特征项）；𝑑 表示一个搜索结果文档；𝑊𝑖 表示特征 𝑞𝑖 的权重；𝑅(𝑞𝑖,𝑑) 表示特征项 𝑞𝑖 与文档 𝑑 的相关性得分。

### BM25 在计算中的作用

大概介绍了一下 BM25 之后，我们来回答上文中提出的问题：**如何判断一个 query 与一个文档是否相关以及它们之间的相关程度呢？**

在上文中，关于准确率和召回率的计算，其实是**预设**了在已经确定哪一部分文档是 query 相关，哪一部分文档是 query 不相关的前提下进行计算。关于排序合理评分的计算上，我们也是**预设**了在已经确定的各个文档对于 query 相关度评分的前提下进行计算。

说到底，我们所说的“预设”实际上是一个标准，是一个可以信赖的结果。**对于一个搜索工具搜索能力的衡量打分，其实可以说是相对于一个令人满意的标准结果进行打分。**

如上文所说，我选取了 BM25 作为这个标准，以 BM25 的搜索结果作为 💯 的标准答案对目标搜索方案产生的搜索结果进行打分。换一种方式来说，我做的事情是以 BM25 的表现对各个搜索工具进行归一化，使得多个搜索工具可以互相进行量化和比较。接下来详细介绍 BM25 是如何参与计算的。

👉 对于准确率和召回率的计算：

1. 将 query 分别和各个搜索文档通过 BM25 以及需要测试的搜索方案进行计算
2. 得到每个文档对于 query 的相关性得分，对于低评分的文档进行过滤（这里的低分可以是一个配置数值）
3. 根据评分进行从大到小的排序，BM25 的计算结果会被认定为与 query 相关的文档（也就是 a + b ），测试方案的计算结果（a + c）
4. 其他不包含在 BM25 的计算结果文档会被认定为与 query 不相关的文档（也就是 c + d ）
5. 最后取测试搜索结果（a + c）与 BM25 的搜索结果（a + b）的交集作为 a 的值，计算准确率和召回率

👉 对于排序合理评分的计算：

排序合理评分采用 DCG 算法进行计算。上文说到 DCG 的计算依据是根据搜索结果的相关度进行计算，这里的相关度使用的不是测试的搜索方案为我们计算的相关度分数，而是采用 BM25 对搜索结果中的每个文档与 query 进行计算得出的相关度分数。

也就是说，我把 **BM25 的计算得出的相关度分数作为用户的喜爱值**，对测试出来的搜索结果进行排序合理性计算。

同时，为了归一化处理，会将 BM25 的搜索结果对自身进行 DCG 评分计算，以这个分数作为满分结果，对搜索功能进行百分制打分，从而拿到最终的排序合理分数。

> 需要特别注意的是，DCG 算法可能更多的是运用在 AB Test 中根据用户的反馈去进行排序校验，引入 BM25 模拟用户的喜爱反馈是本方案特别提出的，目前不具备参考实践！

看到这里，你可能会有这样的疑问，排序合理评分有可能达到满分（100）吗？

其实是有可能的！虽然 DCG 算法是一个单调递增的函数（是一个非线性的缓慢增长的函数），但是在测试结果非常精准但少的情况下（准确率高、召回率、结果几乎都为相关评分非常高），排序评分会是一个比较高的值，那些相关评分比较低的文档对于排序分数影响将会非常小，在归一化处理过程中非常容易被四舍五入掉了~ 我认为这个也是合理的，在实际场景下，末尾几个相关度很低很低的文档排在倒一还是倒二我们并不需要在乎。

以上～ 正文已经阐述完毕了🎉

这个方案也许存在不严谨的地方，只是大概提出了一些通用的解决思路，在许多方面还不是特别完善。在完成这个方案的时候，我同时也编写了一个简易的可视化工具，这个工具实现了几个指标的计算和大量测试数据的接入，最终是验证了这套方案可以帮助初步量化主流的静态内容搜索方案的搜索能力的。

不得不说，搜索能力的好坏跟具体的业务场景关联性很强，例如有一些只支持中文搜索，一些支持英文搜索，中英混合搜索。对于中文搜索场景，使用合适的分词方案是非常重要的。另外，不管是什么样的语言场景下，一些特有搭配是不能分割开的，例如公司名、产品名称等专有名词。

当然对这种固有搭配是有很多解决方法的，例如设置白名单干预，或是添加 query 出现顺序的权重，也许可能后续会更新这部分问题的解决思路～

最后的最后，感谢你看完这篇博客！希望可以给你带来一些灵感 ～

## 参考文章

- [一文看懂机器学习指标：准确率、精准率、召回率、F1、ROC曲线、AUC曲线](https://easyaitech.medium.com/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8C%87%E6%A0%87-%E5%87%86%E7%A1%AE%E7%8E%87-%E7%B2%BE%E5%87%86%E7%8E%87-%E5%8F%AC%E5%9B%9E%E7%8E%87-f1-roc%E6%9B%B2%E7%BA%BF-auc%E6%9B%B2%E7%BA%BF-19b1ed9e9260)
- [Ranking算法评测指标之 CG、DCG、NDCG](https://zhuanlan.zhihu.com/p/136199536)
- [经典搜索核心算法：BM25及其变种](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/AI%E6%8A%80%E6%9C%AF%E5%86%85%E5%8F%82/032%20%E7%BB%8F%E5%85%B8%E6%90%9C%E7%B4%A2%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%9ABM25%E5%8F%8A%E5%85%B6%E5%8F%98%E7%A7%8D%EF%BC%88%E5%86%85%E9%99%84%E5%85%A8%E5%B9%B4%E7%9B%AE%E5%BD%95%EF%BC%89.md)
